== 4. Microservices Lab scenario

=== Table Of Content

- link:03_scenario.adoc#installing-hal-tool[Installing Hal Tool]
- link:03_scenario.adoc#create-a-git-project[Create a Git Project]
- link:03_scenario.adoc#create-a-new-namespace[Create a namespace]
- link:03_scenario.adoc#scaffold-the-spring-boot-applications[Scaffold the Spring Boot components]
- link:03_scenario.adoc#build-the-project[Compile the project]
- link:03_scenario.adoc#push-the-components[Push the jar]
- link:03_scenario.adoc#create-a-postgresql-db[Create the DB Capability]
- link:03_scenario.adoc#link-the-microservices[Link/Bind the microservices]
- link:03_scenario.adoc#connect-to-the-client-or-backend-services[Connect to the Microservices]

=== Installing Hal tool

Download and install the `hal` tool from the project `https://github.com/halkyonio/hal/releases/tag/v0.1.2`

===== Binary installation for Mac OS

----
# curl -sL https://github.com/halkyonio/hal/releases/download/v0.1.5/hal_0.1.5_Darwin_x86_64.tar.gz | tar -xz -C /usr/local/bin/ && chmod +x /usr/local/bin/hal
----

===== Binary installation for Linux

----
# curl -sL https://github.com/halkyonio/hal/releases/download/v0.1.5/hal_0.1.5_Linux_x86_64.tar.gz \
    -o /usr/local/bin/hal_0.1.5_Linux_x86_64.tar.gz && \
    tar -xzf /usr/local/bin/hal_0.1.5_Linux_x86_64.tar.gz && \
    chmod +x /usr/local/bin/hal
----

**Remark**:

If the `/usr/local/bin` folder is owned by `root` and that your user don't has the permissions, then prefix the command with `sudo`.
----
sudo curl -sL https://github.com/halkyonio/hal/releases/download/v0.1.1/hal_0.1.5_Linux_x86_64.tar.gz \
  -o /usr/local/bin/hal_0.1.5_Linux_x86_64.tar.gz && \
  sudo tar -xzf /usr/local/bin/hal_0.1.5_Linux_x86_64.tar.gz \
  -C /usr/local/bin && sudo chmod +x /usr/local/bin/hal
----

===== Windows

In order to use `hal` you must download it and add it to your `PATH` environment variable:

. Download the `hal_0.1.5_Windows_x86_64.tar.gz` file from the link:https://github.com/halkyonio/hal/releases[GitHub releases page].
. Extract the `hal.exec` file from the compressed archive.
. Add the location of the extracted binary to your `PATH` environment under by example `c:\tools`.

===== Docker

If Docker is installed on your laptop and that you can access it, then you can also use the following `Hal` container image to play with it

NOTE: The image already packages the `oc` client version 4.x.

----
docker run --name hal -v "/path/to/lab/dir:/home/lab" -it quay.io/halkyonio/hal:v0.1.5 bash
hal version
----

**Remark**: Check with the instructor the latest image to be used for the hal tool !!

Using this docker container, you can also execute the `oc` commands as presented hereafter
----
docker run --name hal -v "/path/to/lab/dir:/home/lab" -it quay.io/halkyonio/hal:v0.1.5 bash
oc login api.cluster-416e.416e.sandbox352.opentlc.com:6443 -u user1 -p r3dh4t1!
The server uses a certificate signed by an unknown authority.
You can bypass the certificate check, but any data you send to the server could be intercepted by others.
Use insecure connections? (y/n): y

Login successful.

You have access to 56 projects, the list has been suppressed. You can list all projects with 'oc projects'
----

=== Create a Git project

Create for your lab a `git repo` within the `org` https://github.com/rhte-eu for the EU Session Lab or https://github.com/rhte-us for the US Session Lab
using as repo name your first and last name concatenated and cut after 8 chars (E.g : Charles Moulliard -> cmoullia)
----
bash <(curl -s https://raw.githubusercontent.com/halkyonio/rhte_lab_2019/master/git-create.sh)
Repo name (hit enter to use 'cmoullia')?
<YOUR_GIT_REPO>
Creating Github repository 'rcmoullia' under 'rhte-eu' ...
curl -u xxxxx:yyyyy https://api.github.com/orgs/rhte-eu/repos -d '{name:$repo_name, description:My cool $repo_name, private: false, has_issues: false, has_projects: true, has_wiki:false }'
done.
----

=== Log on to the OpenShift cluster

Log on to the RHTE OCP4 cluster using the `oc` client
----
oc login <SERVER_ADDRESS> -u user1 -p r3d4t1!
----

**Remarks**:
- The `<SERVER_ADDRESS>` corresponds to the Openshift API Server address (e.g: `api.cluster-416e.416e.sandbox352.opentlc.com:6443`) as reported within the lab setup part.
- As every student has a dedicated OCP cluster, then always use the user --> `user1`

Grant the `admin` role to your user `user1`
----
oc adm policy add-cluster-role-to-user admin user1 --as=system:admin
----

=== Create a new namespace

Create a new namespace
----
oc new-project rhtelab
----

=== Scaffold the Spring Boot applications

Create on your laptop under your development folder the `rhtelab` folder and move it there
----
mkdir rhtelab && cd rhtelab
----

Create a `pom.xml` file and add the following content:

----
<?xml version="1.0" encoding="UTF-8"?>
<!--
Copyright 2016-2017 Red Hat, Inc, and individual contributors.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>me.fruitsand</groupId>
    <artifactId>parent</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <name>Spring Boot - Demo</name>
    <description>Spring Boot - Demo</description>
    <packaging>pom</packaging>
    <modules>
        <module>fruit-backend-sb</module>
        <module>fruit-client-sb</module>
    </modules>
</project>

---- 

Create a new client project using the REST HTTP `client` template proposed by the scaffolding tool:
----
hal component spring-boot \
   -i fruit-client-sb \
   -g me.fruitstand \
   -p me.fruitstand.demo \
   -s 2.1.6.RELEASE \
   -t client \
   -v 1.0.0-SNAPSHOT \
   --supported=false  \
  fruit-client-sb
----

Repeat the operation and use as template the `crud` type and `fruit-backend-sb` as maven project name:
----
hal component spring-boot \
   -i fruit-backend-sb \
   -g me.fruitstand \
   -p me.fruitstand.demo \
   -s 2.1.6.RELEASE \
   -t crud \
   -v 1.0.0-SNAPSHOT \
   --supported=false  \
  fruit-backend-sb
----

Create a `.gitignore` file ignore the files populated by your IDE or what maven will populate under `/target` directory
----
touch .gitignore
echo "*/target" >> .gitignore
echo ".idea/" >> .gitignore
----

Add the code scaffolded to your git project and push it to your git remote repository
----
git init
git add .gitignore fruit-backend-sb/ fruit-client-sb/
git commit -m "Initial project" -a
git remote add origin https://github.com/<RHTE_ORG>/<YOUR_REPO_NAME>.git
git push -u origin master
----
Note that the user and password to push to the repo are `username="rhte-user" password="!demo12345"`

=== Build the project

==== Client

Compile and generate the `uber jar` file of the Spring Boot application using the following command
----
mvn package -f fruit-client-sb
----

==== Backend

Repeat the command executed previously for the CRUD - backend microservice
----
mvn package -f fruit-backend-sb -Pkubernetes
----

**Remark**: We need to use the `kubernetes` profile because the project is set up to work both locally using H2 database for quick testing and "remotely" using a PostgreSQL database.

The  PostgreSQL connection information is provided in the `application-kubernetes.properties` file.

Note also that this file contains a Dekorate environment variable definition called `SPRING_PROFILES_ACTIVE` with a `kubernetes` value.
This is so that the supervisor knows to activate the Spring `kubernetes` profile, i.e. make Spring Boot uses `application-kubernetes.properties` when
booting instead of the default `application.properties`. `application-kubernetes.properties` relies on the existence of
environment variables for the different components of the database connection. These values will be provided by a database
capability to which our component will be linked: the capability will generate a secret containing these values and the link will
inject it our component. The secret will be named after your capability, adding the `-config` suffix to the name. So if your
capability is called `my-capability`, its associated secret will be named `my-capability-config`.

=== Push the Components

TODO: Explain a little what is a component and what will happen when we will do the push

Before to push the project and to deploy the applications as components, check if you are using your project
----
oc project
Using project "rhtelab" on server "https://api.cluster-416e.416e.sandbox352.opentlc.com:6443".
----

Next deploy the components
----
hal component push -c fruit-client-sb,fruit-backend-sb
'fruit-client-sb' component was not found, initializing it
 ◐  Waiting for component fruit-client-sb to be ready…
 ✓  Uploading /Users/dabou/Temp/rhtelab/fruit-client-sb/target/fruit-client-sb-1.0.0-SNAPSHOT.jar
'fruit-backend-sb' component was not found, initializing it
...
----

Check if the components have been correctly installed within another terminal
----
oc get cp
NAME               RUNTIME       VERSION         AGE       MODE      STATUS    MESSAGE                                                                    REVISION
fruit-backend-sb   spring-boot   2.1.6.RELEASE   11s       dev       Pending   pod is not ready for Component 'fruit-backend-sb' in namespace 'rhtelab'
fruit-client-sb    spring-boot   2.1.6.RELEASE   103s      dev       Ready     Ready
----

NOTE: though that if you access the associated services, they won't be working yet
because the components haven't been wired together yet. Hence why we need to following steps! :smile:

=== Create a PostgreSQL DB

Create a capability to install a PostgreSQL database using the interactive mode of the `hal` tool.
Select as category: `database`, Type: `postgres` and version : `10`
----
hal capability
? Category database
? Type postgres
? Version 10
? Change default name (postgres-capability-1568134805423273000)
? Enter a value for string property DB_NAME: sample-db
? Enter a value for string property DB_PASSWORD: admin
? Enter a value for string property DB_USER: admin
 ✓  Created capability postgres-capability-1568134805423273000
----

Check the capability status:
----
oc get capabilities
NAME                                      CATEGORY   KIND      AGE       STATUS    MESSAGE                                                                                                      REVISION
postgres-capability-1568134805423273000   Database             25s       Pending   postgreSQL db is not ready for Capability 'postgres-capability-1568134805423273000' in namespace 'rhtelab'
----

=== Link the microservices

NOTE: The fruit-client-sb's `application.properties` relies on an environment variable called `${KUBERNETES_ENDPOINT_FRUIT}` as a value provider for the `endpoint.fruit` property.
This is the property the app relies on to connect to the backend endpoint.

We will therefore need to somehow provide a value for this environment variable. This will be accomplished by creating a link.

We also need to wire the `fruit-backend-sb` component with the `postgres-db` capability by creating a link between both:
----
hal link
select `component: fruit-backend-sb` as the target since we want to enrich/link the `fruit-backend-sb` component with the information
about the paraneters of the Database created previously
select secret as link type
select `<your capability name>-config` as secret (`postgres-db-config` if your capability is called `postgres-db`)
call the link whatever you want

hal link
? Target component: fruit-backend-sb
? Use Secret Yes
? Secret  [Use arrows to move, space to select, type to filter]
  deployer-token-8jg7f
  deployer-token-g2nh2
  postgres-capability-156813480542327300-bba890eb-dockercfg-zljff
> postgres-capability-1568134805423273000-config
? Change default name fruit-backend-sb-link-1568136120947947000
 ✓  Created link fruit-backend-sb-link-1568136120947947000
----

Create a link targeting the `fruit-client-sb` component: `hal link` to let `fruit-client-sb` know about the backend:
----
hal link
select `component: fruit-client-sb` as the target
select no when asked whether to use a secret
enter `KUBERNETES_ENDPOINT_FRUIT=http://fruit-backend-sb:8080/api/fruits` as the env value
press enter to let `hal` know that you're done entering env variables

hal link
? Target component: fruit-client-sb
? Use Secret No
? Env variable in the 'name=value' format, press enter when done KUBERNETES_ENDPOINT_FRUIT=http://fruit-backend-sb:8080/api/fruits
Set env variable: KUBERNETES_ENDPOINT_FRUIT=http://fruit-backend-sb:8080/api/fruits
? Env variable in the 'name=value' format, press enter when done
? Change default name fruit-client-sb-link-1568136198776371000
 ✓  Created link fruit-client-sb-link-1568136198776371000
----
Check the link status:
----
oc get links
NAME                                        AGE       STATUS    MESSAGE
fruit-backend-sb-link-1568136120947947000   93s       Ready     Ready
fruit-client-sb-link-1568136198776371000    14s       Ready     Ready
----

TODO: Add command to check if the component has been modified and is well started

=== Connect to the Client or Backend services

Try the backend service to see if it works
So, get the route address of the backend microservice using this command `oc get routes/fruit-backend-sb --template={{.spec.host}}`
Copy/paste the address displayed within the terminal in a browser and create some fruits

image::images/fruits-backend.png[]

Try the client microservice to see if it works too.
So, get also its route address using this command `oc get routes/fruit-client-sb --template={{.spec.host}}`
and curl the service within your terminal, you should get the fruits created in the previous step.
----
FRONTEND_URL=<host-of-client-route>
curl http://${FRONTEND_URL}/api/client
[{"id":4,"name":"orange"},{"id":5,"name":"apple"},{"id":6,"name":"strawberry"}]
----

==== Switch to build mode

When we have finished to test/push the project on the cloud machine, then we can start the process to build a docker image. Again, this process
is greatly simplified using the `hal` tool as it will allow to change the property `deploymentMode` of the `Component` to use `build`. This
parameter will be used by the operator and Tekton to perform a s2i Build.

Prior to do that, change the default profile of pom.xml of the project `fruit-backend-sb` to make the `Kubernetes` the default one.
Commit the code.
----
<profile>
 <id>kubernetes</id>
 <activation>
   <activeByDefault>true</activeByDefault>
   </activation>
----

Next, you can use the `hal` command to perform this switch
----
hal component switch -m build -c fruit-client-sb
hal component switch -m build -c fruit-backend-sb
----

TODO: Add text here to tell to the students what is happening, what they could do

Test again the service
----
open "http://$(oc get routes/fruit-backend-sb --template={{.spec.host}})"
FRONTEND_URL=$(oc get routes/fruit-client-sb --template={{.spec.host}})
curl "http://${FRONTEND_URL}/api/client"
----

The Halkyon Team ;-)

**link:README.adoc[Home]**