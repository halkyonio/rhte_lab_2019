== 4. Microservices Lab scenario

=== Table Of Content

* link:03_scenario.adoc#installing-hal-tool[Installing Hal Tool]
** link:03_scenario.adoc#binary-installation-for-mac-os[Macos]
** link:03_scenario.adoc#binary-installation-for-linux[Linux]
** link:03_scenario.adoc#windows[Windows]
** link:03_scenario.adoc#docker[Docker]
* link:03_scenario.adoc#create-a-git-project[Create a Git Project]
* link:03_scenario.adoc#create-a-new-namespace[Create a namespace]
* link:03_scenario.adoc#scaffold-the-spring-boot-applications[Scaffold the Spring Boot components]
* link:03_scenario.adoc#build-the-project[Build the project]
* link:03_scenario.adoc#create-the-components[Create the components]
* link:03_scenario.adoc#create-a-postgresql-db[Create the DB Capability]
* link:03_scenario.adoc#link-the-microservices[Link/Bind the microservices]
* link:03_scenario.adoc#push-the-code[Push the code source]
* link:03_scenario.adoc#connect-to-the-client-or-backend-services[Connect to the Microservices]

---

=== Installing Hal tool

Download and install the `hal` developer tool from the project `https://github.com/halkyonio/hal/releases/tag/v0.1.5`. This tool will help you
to scaffold your spring applications, to deploy it on the cluster and to perform the `Link/Binding` manipulations like, such as,
create the PostgreSQL database.

==== Binary installation for Mac OS

----
# curl -sL https://github.com/halkyonio/hal/releases/download/v0.1.6/hal_0.1.6_Darwin_x86_64.tar.gz | tar -xz -C /usr/local/bin/ && chmod +x /usr/local/bin/hal
----

==== Binary installation for Linux

----
# curl -sL https://github.com/halkyonio/hal/releases/download/v0.1.6/hal_0.1.6_Linux_x86_64.tar.gz \
    -o /usr/local/bin/hal_0.1.6_Linux_x86_64.tar.gz && \
    tar -xzf /usr/local/bin/hal_0.1.6_Linux_x86_64.tar.gz && \
    chmod +x /usr/local/bin/hal
----

**Remark**:

If a `/usr/local/bin` folder is owned by a `root` and your user doesn't have required permissions, then prefix the command with `sudo`.
----
sudo curl -sL https://github.com/halkyonio/hal/releases/download/v0.1.1/hal_0.1.6_Linux_x86_64.tar.gz \
  -o /usr/local/bin/hal_0.1.6_Linux_x86_64.tar.gz && \
  sudo tar -xzf /usr/local/bin/hal_0.1.6_Linux_x86_64.tar.gz \
  -C /usr/local/bin && sudo chmod +x /usr/local/bin/hal
----

==== Windows

In order to use `hal` you must download it and add it to your `PATH` environment variable:

. Download the `hal_0.1.6_Windows_x86_64.tar.gz` file from the link:https://github.com/halkyonio/hal/releases[GitHub releases page].
. Extract the `hal.exec` file from the compressed archive.
. Add the location of the extracted binary to your `PATH` environment under by example `c:\tools`.

==== Docker

If Docker is installed on your laptop and you can access it, then you can also use the following `Hal` container image to play with it

NOTE: The image already packages the `oc` client version 4.x.

----
docker run --name hal -v "/path/to/lab/dir:/home/lab" -it quay.io/halkyonio/hal:v0.1.6 bash
hal version
----

**Remark**: Check with the instructor for the latest image to be used for the hal tool !!

Using this docker container, you can also execute the `oc` commands as presented hereafter
----
docker run --name hal -v "/path/to/lab/dir:/home/lab" -it quay.io/halkyonio/hal:v0.1.6 bash
oc login api.cluster-416e.416e.sandbox352.opentlc.com:6443 -u user1 -p r3dh4t1!
The server uses a certificate signed by an unknown authority.
You can bypass the certificate check, but any data you send to the server could be intercepted by others.
Use insecure connections? (y/n): y

Login successful.

You have access to 56 projects, the list has been suppressed. You can list all projects with 'oc projects'
----

=== Create a Git project

Create a `git repo` within the `org` https://github.com/rhte-eu for the EU Session Lab or https://github.com/rhte-us for the US Session Lab
using your first and last name concatenated and cut after 8 chars as a repo name  (E.g : Charles Moulliard -> cmoullia)
----
bash <(curl -s https://raw.githubusercontent.com/halkyonio/rhte_lab_2019/master/scripts/git-create.sh)
Repo name (hit enter to use 'cmoullia')?
<YOUR_GIT_REPO>
Creating Github repository 'cmoullia' under 'rhte-eu' ...
curl -u xxxxx:yyyyy https://api.github.com/orgs/rhte-eu/repos -d '{name:$repo_name, description:My cool $repo_name, private: false, has_issues: false, has_projects: true, has_wiki:false }'
done.
----

=== Log on to the OpenShift cluster

Log on to the RHTE OCP4 cluster using the `oc` client
----
oc login <SERVER_ADDRESS> -u user1 -p r3dh4t1!
----

**Remarks**:
- The `<SERVER_ADDRESS>` corresponds to the Openshift API Server address (e.g: `api.cluster-416e.416e.sandbox352.opentlc.com:6443`) as reported within the lab setup part.
- As every student has a dedicated OCP cluster, always use the user --> `user1`

Grant the `admin` role to your user `user1`
----
oc adm policy add-cluster-role-to-user admin user1 --as=system:admin
----

=== Create a new namespace

Create a new namespace
----
oc new-project rhtelab
----

=== Scaffold the Spring Boot applications

Create a `rhtelab` development folder on your laptop
----
mkdir rhtelab && cd rhtelab
----

Create a `pom.xml` file and add the following content:

----
<?xml version="1.0" encoding="UTF-8"?>
<!--
Copyright 2016-2017 Red Hat, Inc, and individual contributors.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>me.fruitsand</groupId>
    <artifactId>parent</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <name>Spring Boot - Demo</name>
    <description>Spring Boot - Demo</description>
    <packaging>pom</packaging>
    <modules>
        <module>fruit-backend-sb</module>
        <module>fruit-client-sb</module>
    </modules>
</project>
----

Create a new client project using the REST HTTP `client` template proposed by the scaffolding tool with the interactive mode.
So, execute the following command where you will answer to the question:

Spring Boot version: `2.1.6.RELEASE`
Supported version: `No`
Create from template: `Yes`
Available templates: `client`
Group Id: `me.fruitsand`
Artifact Id: `fruit-client-sb`
Version: `1.0.0-SNAPSHOT`
Package name: `me.fruitsand.demo`

Verify that a project has been locally created, contains `src/main/java` directory like a pom.xml file with the information provided.
----
hal component spring-boot fruit-client-sb
? Spring Boot version 2.1.6.RELEASE
? Use 2.1.6.RELEASE supported version No
? Create from template Yes
? Available templates client
? Group Id me.fruitsand
? Artifact Id fruit-client-sb
? Version 1.0.0-SNAPSHOT
? Package name me.fruitsand.demo
----

Repeat the operation and use as template the `crud` type and `fruit-backend-sb` as maven project name but without now the interactive mode:
----
hal component spring-boot \
   -i fruit-backend-sb \
   -g me.fruitsand \
   -p me.fruitsand.demo \
   -s 2.1.6.RELEASE \
   -t crud \
   -v 1.0.0-SNAPSHOT \
   --supported=false  \
  fruit-backend-sb
----

Create a `.gitignore` file to ignore the files populated by your IDE or what maven will populate under `/target` directory
----
touch .gitignore
echo "*/target" >> .gitignore
echo ".idea/" >> .gitignore
----

Add the code scaffolded to your git project and push it to your git remote repository
----
git init
git add .gitignore pom.xml fruit-backend-sb/ fruit-client-sb/
git commit -m "Initial project" -a
git remote add origin https://rhte-user:\!demo12345@github.com/<RHTE_ORG>/<YOUR_REPO_NAME>.git
git push -u origin master
----
Note that the user and password to push to the repo are `username="rhte-user" password="!demo12345"`

=== Build the project

==== Client

Compile and generate the `uber jar` file of the Spring Boot application using the following command
----
mvn package -f fruit-client-sb
----

==== Backend

Repeat the command executed previously for the CRUD - backend microservice
----
mvn package -f fruit-backend-sb -Plocal
----

**Remark**: We need to use the `local` profile because the project is set up to work both locally using `H2` database for quick testing and "remotely" using a `PostgreSQL` database
using the `kubernetes` profile which is enable by default.

The `PostgreSQL` connection information is provided in the `application-kubernetes.properties` file.

Note also that this file contains a Dekorate environment variable definition called `SPRING_PROFILES_ACTIVE` with a `kubernetes` value.
This is so that the supervisor knows to activate the Spring `kubernetes` profile, i.e. make Spring Boot uses `application-kubernetes.properties` when
booting instead of the default `application.properties`. File, `application-kubernetes.properties` contains the environment variables
for the different components of the database connection. These values will be used by a database
capability and will be linked to the component: the capability will generate a secret containing these values and the link will
inject it in our component. The secret will be named after your capability, adding the `-config` suffix to the name. So if your
capability is called `my-capability`, its associated secret will be named `my-capability-config`.

=== Create the Components

A component represents a micro-service to be deployed. The Component custom resource provides the descriptor that allows Kubernetes/OpenShift
to deploy the micro-service and, optionally, expose it outside of the cluster.
To deploy a microservice two actions need to be done: create the component and push the uber java file.

Before to push the project and to deploy the applications as components, check if you are using your project
----
oc project
Using project "rhtelab" on server "https://api.cluster-416e.416e.sandbox352.opentlc.com:6443".
----

Next create the different microservices as `component` using the command `hal component create`. During this process, the tool
will communicate with the platform to deploy the `Component CRD` resource. Next the halkyon operator will process the content
and will create different kubernetes resources that you don't have to take care yourself anymore such as: Deployment, Service, ...
----
hal component create -c fruit-client-sb
'fruit-client-sb' component was not found, initializing it
 ✓  Waiting for component fruit-client-sb to be ready…
 ✓  Successfully created 'fruit-client-sb' component
hal component create -c fruit-backend-sb
'fruit-backend-sb' component was not found, initializing it
 ✓  Waiting for component fruit-backend-sb to be ready…
 ✓  Successfully created 'fruit-backend-sb' component
----

Check if the components have been correctly installed within another terminal
----
oc get cp
NAME               RUNTIME       VERSION         AGE       MODE      STATUS    MESSAGE                                                                    REVISION
fruit-backend-sb   spring-boot   2.1.6.RELEASE   11s       dev       Pending   pod is not ready for Component 'fruit-backend-sb' in namespace 'rhtelab'
fruit-client-sb    spring-boot   2.1.6.RELEASE   103s      dev       Ready     Ready
----

NOTE: if you will try to access the associated services, they won't work because the components haven't been wired together yet. Hence the need for the following steps! :smile:

=== Create a PostgreSQL DB

Create a capability to install a PostgreSQL database using the interactive mode of the `hal` tool.
Select as :
- Category: `database`
- Type: `postgres`
- version : `10`
- Default-name: `postgres-db`

For the database parameters which are needed to configure the instance of the Database but also the parameters of the Java Datasource
used by the Spring JPA component, use the following ket, value pairs:
- DB_NAME: `sample-db`
- DB_PASSWORD: `admin`
- DB_USER: `admin`

----
hal capability create
? Category database
? Type postgres
? Version 10
? Change default name (postgres-db)
? Enter a value for string property DB_NAME: sample-db
? Enter a value for string property DB_PASSWORD: admin
? Enter a value for string property DB_USER: admin
 ✓  Created capability postgres-db
----

Check the capability status:
----
oc get capabilities
NAME                                      CATEGORY   KIND      AGE       STATUS    MESSAGE                                                                                                      REVISION
postgres-capability-1568134805423273000   Database             25s       Pending   postgreSQL db is not ready for Capability 'postgres-capability-1568134805423273000' in namespace 'rhtelab'
----

If the status is not ready, wait a few moment till the `KubeDB` operator create the database within your namespace and repeat the command again
----
oc get capability
NAME          CATEGORY   KIND      AGE       STATUS    MESSAGE   REVISION
postgres-db   Database             4m        Ready     Ready
----

=== Link the microservices

NOTE: The fruit-client-sb's `application.properties` relies on an environment variable called `${KUBERNETES_ENDPOINT_FRUIT}` as a value provider for the `endpoint.fruit` property.
This is the property the app relies on to connect to the backend endpoint.

We will therefore need to somehow provide a value for this environment variable. This will be accomplished by creating a link.
We also need to wire the `fruit-backend-sb` component with the `postgres-db` capability by creating a link between both.

So, execute the command `hal link create` to use the interactive mode and next select:
- Target: component: `fruit-backend-sb` as the target since we want to enrich/link the `fruit-backend-sb` component with the information about the parameters of the Database created previously
- Use secret: `Y` as the information created during the encoding of the parameters of the capability are stored in a secret
- Secret (only potential matches shown) : `postgres-db-config`
- Change default name (fruit-backend-sb-link-1568907618694167000): `fruit-backend-sb-link`

----
hal link create
? Target component: fruit-backend-sb
? Use Secret Yes
Selected link type: Secret
? Secret (only potential matches shown) postgres-db-config
? Change default name fruit-backend-sb-link
 ✓  Created link fruit-backend-sb-link
----

Create a link targeting the `fruit-client-sb` component using again the command `hal link` to let `fruit-client-sb` know about the backend.
- Target: `component: fruit-client-sb`
- Use Secret: `No`
- Env variable in the 'name=value': `KUBERNETES_ENDPOINT_FRUIT=http://fruit-backend-sb:8080/api/fruits`
- Change default name: `fruit-client-sb-link`
----
hal link create
? Target component: fruit-client-sb
? Use Secret No
Selected link type: Env
? Env variable in the 'name=value' format, press enter when done KUBERNETES_ENDPOINT_FRUIT=http://fruit-backend-sb:8080/api/fruits
Set env variable: KUBERNETES_ENDPOINT_FRUIT=http://fruit-backend-sb:8080/api/fruits
? Env variable in the 'name=value' format, press enter when done
? Change default name fruit-client-sb-link
 ✓  Created link fruit-client-sb-link
----
Check the link status:
----
oc get links
NAME                    AGE       STATUS    MESSAGE
fruit-backend-sb-link   4m        Ready     Ready
fruit-client-sb-link    2m        Ready     Ready
----

TODO: Add command to check if the component has been modified and has started correctly

=== Push the code

Now that we have created the different entities able to design the architecture of the microservices, their relations
and backend service, we will push the code (to compile it on the platform) and to verify if we can access the HTTP endpoints
exposed as route

----
hal component push -c fruit-client-sb -s
 ✓  Uploading /Users/dabou/Temp/rhtelab/fruit-client-sb.tar
hal component push -c fruit-backend-sb -s
 ✓  Uploading /Users/dabou/Temp/rhtelab/fruit-backend-sb.tar
----

=== Connect to the Client or Backend services

Try the backend service to see if it works
So, get the route address of the backend microservice using this command `oc get routes/fruit-backend-sb --template={{.spec.host}}`
Copy/paste the address displayed within the terminal in a browser and create some fruits

image::images/fruits-backend.png[]

Try the client microservice to see if it works too.
So, get also its route address using this command `oc get routes/fruit-client-sb --template={{.spec.host}}`
and curl the service within your terminal, you should get the fruits created in the previous step.
----
FRONTEND_URL=<host-of-client-route>
curl http://${FRONTEND_URL}/api/client
[{"id":4,"name":"orange"},{"id":5,"name":"apple"},{"id":6,"name":"strawberry"}]
----

=== Switch to build mode

When we have finished to test/push the project on the cloud machine, then we can start the process to build a docker image. Again, this process
is greatly simplified using the `hal` tool as it will allow to change the property `deploymentMode` of the `Component` to use `build`. This
parameter will be used by the operator and Tekton to perform a s2i Build.

Prior to do that, change the default profile of pom.xml of the project `fruit-backend-sb` to make the `Kubernetes` the default one.
Commit the code.
----
<profile>
 <id>kubernetes</id>
 <activation>
   <activeByDefault>true</activeByDefault>
   </activation>
----

Next, you can use the `hal` command to perform this switch
----
hal component switch -m build -c fruit-client-sb
hal component switch -m build -c fruit-backend-sb
----

TODO: Add text here to tell to the students what is happening, what they could do

Test the service again
----
open "http://$(oc get routes/fruit-backend-sb --template={{.spec.host}})"
FRONTEND_URL=$(oc get routes/fruit-client-sb --template={{.spec.host}})
curl "http://${FRONTEND_URL}/api/client"
----

The Halkyon Team ;-)

**link:README.adoc[Home]**
