== Microservices Lab scenario

=== Installing Hal tool

Download and install the `hal` tool from the project `https://github.com/halkyonio/hal/releases/tag/v0.1.2`

===== Binary installation for Mac OS

----
# curl -sL https://github.com/halkyonio/hal/releases/download/v0.1.1/hal_0.1.1_Darwin_i386.tar.gz | tar -xz -C /usr/local/bin/ && chmod +x /usr/local/bin/hal
----

===== Binary installation for Linux

----
# curl -sL https://github.com/halkyonio/hal/releases/download/v0.1.1/hal_0.1.1_Linux_x86_64.tar.gz -o /usr/local/bin/ && chmod +x /usr/local/bin/hal
----

===== Windows

TODO

=== Create a Git project

Git clone a project within a terminal from the github org https://github.com/rhte-eu (for the EU Session Lab) or https://github.com/rhte-us (for the US Session Lab)
using as repo name `user**1**`, ....., `user**N**`

----
git clone https://github.com/rhte-eu/user1.git
----

Rename the name of the cloned project to `rhtelab` and move under this folder
----
mv user1 rhtelab && cd rhtelab
----

=== Log on to the Openshift cluster

Log on tothe RHTE OCP4 cluster using the `oc` client
----
oc login <URL> -u user1 -p r3d4t1!
----
Grant the `admin` role to your user `user1`
----
oc adm policy add-cluster-role-to admin user1 --as=system:admin
----
IMPORTANT: As every student has a dedicated OCP cluster, then always use the user : `user1`

=== Create a new namespace

Create a new namespace
----
oc new-project rhtelab
----

=== Scaffold the Spring Boot applications

Create a new client project using the `client` template in a `fruit-client-sb` directory:
    * `hal component spring-boot fruit-client-sb` (interactive mode)
    * TODO: add non-interactive version of the command

Create a new backend project using the `crud` template in a `fruit-backend-sb` directory:
    * `hal component spring-boot fruit-backend-sb` (interactive mode)
    * TODO: add non-interactive version of the command

=== Build the project

==== Client

Build the client project: `mvn package -f fruit-client-sb`.

NOTE: The project's `application.properties` relies on an environment variable called `${KUBERNETES_ENDPOINT_FRUIT}` as a value provider for the `endpoint.fruit` property.
This is the property the app relies on to connect to the backend endpoint.

We will therefore need to somehow provide a value for this environment variable. This will be accomplished by creating a link.

==== Backend

Build the backend project: `mvn package -f fruit-backend-sb -Pkubernetes`.
We need to use the `kubernetes` profile because the
project is set up to work both locally using H2 database for quick testing and "remotely" using a PostgreSQL database. The
PostgreSQL connection information is provided in the `application-kubernetes.properties` file. Note also that this file contains
a Dekorate environment variable definition called `SPRING_PROFILES_ACTIVE` with a `kubernetes` value. This is so that the
supervisor knows to activate the Spring `kubernetes` profile, i.e. make Spring Boot uses `application-kubernetes.properties` when
booting instead of the default `application.properties`. `application-kubernetes.properties` relies on the existence of
environment variables for the different components of the database connection. These values will be provided by a database
capability to which our component will be linked: the capability will generate a secret containing these values and the link will
inject it our component. The secret will be named after your capability, adding the `-config` suffix to the name. So if your
capability is called `my-capability`, its associated secret will be named `my-capability-config`.

Push components: `hal component push -c fruit-client-sb,fruit-backend-sb`
Wait… :(

Components should be ready: `kubectl get cp`/`oc get cp`.

NOTE:  though that if you access the associated services, they won't be working yet
because the components haven't been wired together yet. Hence why we need to following steps! :smile:

==== Create a PostgreSQL DB

Create a capability to create a PostgreSQL database:
    * `hal capability` in interactive mode: select version `10`, TODO: provide the detail of all the values to enter,
    name the capability: `postges-db`
    * TODO: add non-interactive command

Check the capability status: `kubectl get capabilities`/`oc get capabilities`

==== Link the microservices

We now need to wire the `fruit-backend-sb` component with the `postgres-db` capability by creating a link between both:
    * `hal link`
    * select `component: fruit-backend-sb` as the target since we want to tell the `fruit-backend-sb` component about the DB
    * select secret as link type
    * select `<your capability name>-config` as secret (`postgres-db-config` if your capability is called `postgres-db`)
    * call the link whatever you want

Create a link targeting the `fruit-client-sb` component: `hal link` to let `fruit-client-sb` know about the backend:
    * `hal link`
    * select `component: fruit-client-sb` as the target
    * select no when asked whether to use a secret
    * enter `KUBERNETES_ENDPOINT_FRUIT=http://fruit-backend-sb:8080/api/fruits` as the env value
    * press enter to let `hal` know that you're done entering env variables

Check the link status: `kubectl get links`/`oc get links`

Wait for things to be settled

Push the components again (TODO: remove when https://github.com/halkyonio/operator/issues/141 is fixed)

==== Connect to the Endpoints/Routes

Try the backend service to see if it works
    - Get the routes `oc get routes`
    - Get the `HOST/PORT` of the `fruit-backend-sb` and paste it in a browser
    - Create some fruits

Try the client service to see if it works
    - Get the routes `oc get routes`
    - Get the `HOST/PORT` of the `fruit-client-sb`
    - `export FRONTEND_ROUTE_URL=<host-of-client-route>`
    - `curl http://${FRONTEND_ROUTE_URL}/api/client`