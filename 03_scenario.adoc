== 4. Microservices Lab scenario

=== Table Of Content

* link:03_scenario.adoc#installing-hal-tool[Installing Hal Tool]
** link:03_scenario.adoc#binary-installation-for-mac-os[Macos]
** link:03_scenario.adoc#binary-installation-for-linux[Linux]
** link:03_scenario.adoc#windows[Windows]
** link:03_scenario.adoc#docker[Docker]
* link:03_scenario.adoc#create-a-git-project[Create a Git Project]
* link:03_scenario.adoc#create-a-new-namespace[Create a namespace]
* link:03_scenario.adoc#scaffold-the-spring-boot-applications[Scaffold the Spring Boot components]
* link:03_scenario.adoc#build-the-project[Build the project]
* link:03_scenario.adoc#create-the-components[Create the components]
* link:03_scenario.adoc#create-a-postgresql-db[Create the DB Capability]
* link:03_scenario.adoc#link-the-microservices[Link/Bind the microservices]
* link:03_scenario.adoc#push-the-code[Push the code source]
* link:03_scenario.adoc#connect-to-the-client-or-backend-services[Connect to the Microservices]
* link:03_scenario.adoc#switch-to-build-mode[Switch to build mode]

'''

=== Installing Hal tool

Download and install the latest version of `hal` from https://github.com/halkyonio/hal/releases/. `hal` is a developer-focused
tool aimed at helping you create microservices applications using Halkyon even easier, by guiding you in your choices as you
create components and link them together.

==== Binary installation for Mac OS

----
# curl -sL https://github.com/halkyonio/hal/releases/download/v0.1.8/hal_0.1.8_Darwin_x86_64.tar.gz | tar -xz -C /usr/local/bin/ && chmod +x /usr/local/bin/hal
----

==== Binary installation for Linux

----
# curl -sL https://github.com/halkyonio/hal/releases/download/v0.1.8/hal_0.1.8_Linux_x86_64.tar.gz \
    -o /usr/local/bin/hal_0.1.8_Linux_x86_64.tar.gz && \
    tar -xzf /usr/local/bin/hal_0.1.8_Linux_x86_64.tar.gz && \
    chmod +x /usr/local/bin/hal
----

**Remark**:

If a `/usr/local/bin` folder is owned by a `root` and your user doesn't have required permissions, then prefix the command with `sudo`.
----
sudo curl -sL https://github.com/halkyonio/hal/releases/download/v0.1.8/hal_0.1.8_Linux_x86_64.tar.gz \
  -o /usr/local/bin/hal_0.1.8_Linux_x86_64.tar.gz && \
  sudo tar -xzf /usr/local/bin/hal_0.1.8_Linux_x86_64.tar.gz \
  -C /usr/local/bin && sudo chmod +x /usr/local/bin/hal
----

==== Windows

Download and add it to your `PATH` environment variable:

. Download the `hal_0.1.8_Windows_x86_64.tar.gz` file from the link:https://github.com/halkyonio/hal/releases[GitHub releases page].
. Extract the `hal.exec` file from the compressed archive.
. Add the location of the extracted binary to your `PATH` environment under by example `c:\tools`.

==== Docker

If Docker is installed on your laptop and you can access it, then you can also use the following `Hal` container image to play with it

NOTE: The `hal` image already packages the `oc` client version 4.x.

Execute this command to mount your current folder (where you will play the lab's scenario) within the container next access the terminal using bash

----
docker run --rm --name hal -v "/path/to/lab/dir:/home/lab" -it quay.io/halkyonio/hal:v0.1.8 bash
----

Now you are inside a container. `hal` needs an active connexion to an OpenShift cluster so before anything, please, log on to the RHTE OCP4 cluster using the `oc` client.
Enter the following command from inside the container:
----
oc login <SERVER_ADDRESS> -u user1 -p r3dh4t1!
----

**Remark**: the `oc login` command should be executed every time you will execute the command `docker run` as the `~/.kube/config `kubernetes configuration is not persisted.

Once this is done, you should be able to run `hal`:
----
hal version
----

**Remark**: Check with the instructor for the latest image to be used for the hal tool !!

Using this docker container, you can execute the `oc` commands as presented hereafter:
----
docker run --name hal -v "/path/to/lab/dir:/home/lab" -it quay.io/halkyonio/hal:v0.1.8 bash
oc login api.cluster-416e.416e.sandbox352.opentlc.com:6443 -u user1 -p r3dh4t1!
The server uses a certificate signed by an unknown authority.
You can bypass the certificate check, but any data you send to the server could be intercepted by others.
Use insecure connections? (y/n): y

Login successful.

You have access to 56 projects, the list has been suppressed. You can list all projects with 'oc projects'
----

=== Create a Git project

Create a `git repo` within the `org` https://github.com/rhte-eu for the EU Session Lab or https://github.com/rhte-us for the US Session Lab
using your first and last name concatenated and cut after 8 chars as git hub repo name  (E.g : for the user Charles Moulliard, then the acronym to be used is `cmoullia`)
----
bash <(curl -s https://raw.githubusercontent.com/halkyonio/rhte_lab_2019/master/scripts/git-create.sh)
Repo name (hit enter to use 'cmoullia')?
<YOUR_GIT_REPO>
Creating Github repository 'cmoullia' under 'rhte-eu' ...
curl -u xxxxx:yyyyy https://api.github.com/orgs/rhte-eu/repos -d '{name:$repo_name, description:My cool $repo_name, private: false, has_issues: false, has_projects: true, has_wiki:false }'
done.
----

=== Log on to the OpenShift cluster

Log on to the RHTE OCP4 cluster using the `oc` client
----
oc login <SERVER_ADDRESS> -u user1 -p r3dh4t1!
----

**Remarks**:
- The `<SERVER_ADDRESS>` corresponds to the OpenShift API Server address (e.g: `api.cluster-416e.416e.sandbox352.opentlc.com:6443`) as reported within the lab setup part.
- As every student has a dedicated OCP cluster, always connect using the user named `user1`

Grant the `admin` role to your user `user1` in order to have acccess to the different projects, to list the resources created by Halkyon.
----
oc adm policy add-cluster-role-to-user admin user1 --as=system:admin
----

**Tip**: You can check if the operator is working fine by executing this oc command: `oc describe -n operators pods -lname=halkyon-operator`

=== Create a new namespace

Create a new namespace
----
oc new-project rhtelab
----

=== Scaffold the Spring Boot applications

Create a `rhtelab` development folder on your laptop
----
mkdir rhtelab && cd rhtelab
----

Create a parent `pom.xml` file as the `hal` client tool is not able to create it and add the following content:

----
<?xml version="1.0" encoding="UTF-8"?>
<!--
Copyright 2016-2017 Red Hat, Inc, and individual contributors.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>me.fruitstand</groupId>
    <artifactId>parent</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <name>Spring Boot - Demo</name>
    <description>Spring Boot - Demo</description>
    <packaging>pom</packaging>
    <modules>
        <module>fruit-backend-sb</module>
        <module>fruit-client-sb</module>
    </modules>
</project>
----

Use `hal` to create, in an interactive fashion, a new Spring Boot project using the REST HTTP `client` template proposed by the scaffolding tool.
So, execute the command `hal component spring-boot fruit-client-sb` by providing the following information to each question:

    Spring Boot version: `2.1.6.RELEASE`
    Supported version: `No`
    Create from template: `Yes`
    Available templates: `client`
    Group Id: `me.fruitstand`
    Artifact Id: `fruit-client-sb`
    Version: `1.0.0-SNAPSHOT`
    Package name: `me.fruitstand.demo`

----
hal component spring-boot fruit-client-sb
? Spring Boot version 2.1.6.RELEASE
? Use 2.1.6.RELEASE supported version No
? Create from template Yes
? Available templates client
? Group Id me.fruitstand
? Artifact Id fruit-client-sb
? Version 1.0.0-SNAPSHOT
? Package name me.fruitstand.demo
----

Check that a project has been well created under the folder `fruit-client-sb`.

Repeat the operation to create a second Spring Boot project using the `crud` template. We'll do it in a non-interactive fashion this time.
`hal` is smart enough to check values you provided and only asks you to provide information when needed (e.g. if a provided value is incorrect):
----
hal component spring-boot \
   -i fruit-backend-sb \
   -g me.fruitstand \
   -p me.fruitstand.demo \
   -s 2.1.6.RELEASE \
   -t crud \
   -v 1.0.0-SNAPSHOT \
   --supported=false  \
  fruit-backend-sb
----

Create a `.gitignore` file to ignore the files populated by your IDE or what maven will populate under `/target` directory
----
touch .gitignore
echo "*/target" >> .gitignore
echo ".idea/" >> .gitignore
----

**Remark**: Add the folder corresponding to your IDE tool if you don't use IntelliJ.

Initialize now a git repository, adding the `pom.xml, .gitignore` files you created earlier along with the two Spring Boot applications and push it to your remote repository:
----
git init
git add .gitignore pom.xml fruit-backend-sb/ fruit-client-sb/
git commit -m "Initial project" -a
git remote add origin https://rhte-user:\!demo12345@github.com/<RHTE_ORG>/<YOUR_REPO_NAME>.git
git push -u origin master
----
**Note** that the user and password to push to the repo are `username="rhte-user"` and `password="!demo12345"`

=== Build the project

==== Client

Package your Spring Boot client application using the following maven commands:
----
mvn package -f fruit-client-sb
----

*Remark*: While this is not important, mandatory to perform such a `mvn package` step, that will allow to verify the code of your project can compiled.

==== Backend

Now, package the backend Spring Boot application, paying special attention to the `local` maven profile:
----
mvn package -f fruit-backend-sb -Plocal
----

**Remarks**:

- We need to use the `local` profile because the project is set up to work both locally using a `H2` database for quick testing and "remotely" using a `PostgreSQL` database.
  The `kubernetes` profile is enabled by default. This information is mirrored within the 2 Spring Boot application properties files under the folder `src/main/resources`.
  The `application.properties` file corresponds to the `local` profile while `application-kubernetes.properties` is used for `kubernetes` deployment.
  These 2 files contains the Spring Boot properties to configure the Datasource needed to access the database.
+
----
src/main/resources/application-kubernetes.properties
spring.datasource.url=jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}
spring.datasource.username=${DB_USER}
spring.datasource.password=${DB_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver
----
+
- Note also that this file contains a `Dekorate environment variable` definition called `SPRING_PROFILES_ACTIVE` with a `kubernetes` value.
This is how Halkyon knows to activate the Spring `kubernetes` profile, i.e. make Spring Boot uses `application-kubernetes.properties` when
booting instead of the default `application.properties`.
+
----
src/main/resources/application-kubernetes.properties
...
dekorate.component.envs[0].name=SPRING_PROFILES_ACTIVE
dekorate.component.envs[0].value=kubernetes
----
+
- Finally, you can also see that the database connection parameters `${DB_xxxxx}`reference environment variables. These values will be injected
into your microservice application when you create a link between it and the appropriate database capability.

=== Create the Components

A component represents a microservice to be deployed. The Component custom resource provides the descriptor that allows Kubernetes/OpenShift
to deploy the microservice and, optionally, expose it outside of the cluster.

Creating and using a component is a two step process: first inform the operator about the component by "creating" it, then make
its associated application available to the cluster to be able to run it by "pushing" it to the cluster.

First check if you are using your project:
----
oc project
Using project "rhtelab" on server "https://api.cluster-416e.416e.sandbox352.opentlc.com:6443".
----

Next create the different microservices as `components` using the `hal component create` command. During this process, the tool
will create a `Component` custom resource which will be handled by the halkyon operator to create all the Kubernetes resources
needed to deploy your application properly. You only need to worry about your component metadata instead of wondering how it
needs to be materialized in the cluster using Deployments, Services, etc…
----
hal component create -c fruit-client-sb
'fruit-client-sb' component was not found, initializing it
 ✓  Waiting for component fruit-client-sb to be ready…
 ✓  Successfully created 'fruit-client-sb' component
hal component create -c fruit-backend-sb
'fruit-backend-sb' component was not found, initializing it
 ✓  Waiting for component fruit-backend-sb to be ready…
 ✓  Successfully created 'fruit-backend-sb' component
----

Check if the components have been correctly installed within another terminal
----
oc get cp
NAME               RUNTIME       VERSION         AGE       MODE      STATUS    MESSAGE                                                                    REVISION
fruit-backend-sb   spring-boot   2.1.6.RELEASE   11s       dev       Pending   pod is not ready for Component 'fruit-backend-sb' in namespace 'rhtelab'
fruit-client-sb    spring-boot   2.1.6.RELEASE   103s      dev       Ready     Ready
----

NOTE: if you try to access the associated services, they won't work because the components haven't been wired together yet. Hence the need for the following steps! :smile:

=== Create a PostgreSQL DB

Create a capability to install a PostgreSQL database using the interactive mode of the `hal` tool.
Select as :
- Category: `database`
- Type: `postgres`
- version : `10`
- Default-name: `postgres-db`

For the database parameters which are needed to configure the instance of the Database but also the parameters of the Java Datasource
used by the Spring JPA component, use the following key-value pairs:
- DB_NAME: `sample-db`
- DB_PASSWORD: `admin`
- DB_USER: `admin`

----
hal capability create
? Category database
? Type postgres
? Version 10
? Change default name (postgres-db)
? Enter a value for string property DB_NAME: sample-db
? Enter a value for string property DB_PASSWORD: admin
? Enter a value for string property DB_USER: admin
 ✓  Created capability postgres-db
----

Check the capability status:
----
oc get capabilities
NAME                                      CATEGORY   KIND      AGE       STATUS    MESSAGE                                                                                                      REVISION
postgres-capability-1568134805423273000   Database             25s       Pending   postgreSQL db is not ready for Capability 'postgres-capability-1568134805423273000' in namespace 'rhtelab'
----

If the status is not ready, wait a few moment for the `KubeDB` operator to create the database within your namespace and repeat the command again
----
oc get capability
NAME          CATEGORY   KIND      AGE       STATUS    MESSAGE   REVISION
postgres-db   Database             4m        Ready     Ready
----

=== Link the microservices

NOTE: `fruit-client-sb` relies on an environment variable called `${KUBERNETES_ENDPOINT_FRUIT}` as a value provider for the `endpoint.fruit` property.
This is the property the app relies on to connect to the backend endpoint.

We will therefore need to somehow provide a value for this environment variable. This will be accomplished by creating a link.
We also need to wire the `fruit-backend-sb` component with the `postgres-db` capability by creating a link between both.

So, execute the command `hal link create` to use the interactive mode and next select:
- Target: `component: fruit-backend-sb` as the target since we want to enrich/link the `fruit-backend-sb` component with the information about the parameters of the Database created previously
- Use secret: `Y` as the information created during the encoding of the parameters of the capability are stored in a secret
- Secret (only potential matches shown) : `postgres-db-config`
- Change default name (fruit-backend-sb-link-1568907618694167000): `fruit-backend-sb-link`

----
hal link create
? Target component: fruit-backend-sb
? Use Secret Yes
Selected link type: Secret
? Secret (only potential matches shown) postgres-db-config
? Change default name fruit-backend-sb-link
 ✓  Created link fruit-backend-sb-link
----

Create a link targeting the `fruit-client-sb` component using again the command `hal link` to let `fruit-client-sb` know about the backend.
- Target: `component: fruit-client-sb`
- Use Secret: `No`
- Env variable in the 'name=value': `KUBERNETES_ENDPOINT_FRUIT=http://fruit-backend-sb:8080/api/fruits`
- Change default name: `fruit-client-sb-link`
----
hal link create
? Target component: fruit-client-sb
? Use Secret No
Selected link type: Env
? Env variable in the 'name=value' format, press enter when done KUBERNETES_ENDPOINT_FRUIT=http://fruit-backend-sb:8080/api/fruits
Set env variable: KUBERNETES_ENDPOINT_FRUIT=http://fruit-backend-sb:8080/api/fruits
? Env variable in the 'name=value' format, press enter when done
? Change default name fruit-client-sb-link
 ✓  Created link fruit-client-sb-link
----
Check the link status:
----
oc get links
NAME                    AGE       STATUS    MESSAGE
fruit-backend-sb-link   4m        Ready     Ready
fruit-client-sb-link    2m        Ready     Ready
----

TODO: Add command to check if the component has been modified and has started correctly

=== Push the code

Now that we have created the different entities able to design the architecture of the microservices, their relations
and backend service, we will push the code (to compile it on the platform) and to verify if we can access the HTTP endpoints
exposed as route

----
hal component push -c fruit-client-sb
 ✓  Uploading /Users/dabou/Temp/rhtelab/fruit-client-sb.tar
hal component push -c fruit-backend-sb
 ✓  Uploading /Users/dabou/Temp/rhtelab/fruit-backend-sb.tar
----

NOTE: if you try to `push` the component again without changing anything locally, `hal` is smart enough to detect it and not do anything as nothing is required in this case. Give it a try, then change the code for one of the app and attempt to push again to see what happens!

=== Connect to the Client or Backend services

Try the backend service to see if it works
So, get the route address of the backend microservice using this command `oc get routes/fruit-backend-sb --template={{.spec.host}}`
Copy/paste the address in a browser. You should see a simple web page allowing you to see fruits and create new ones.

image::images/fruits-backend.png[]

Try the client microservice to see if it works too.
So, get also its route address using this command `oc get routes/fruit-client-sb --template={{.spec.host}}`
and curl the service within your terminal, you should get the fruits created in the previous step.
----
FRONTEND_URL=<host-of-client-route>
curl "http://${FRONTEND_URL}/api/client"
[{"id":4,"name":"orange"},{"id":5,"name":"apple"},{"id":6,"name":"strawberry"}]
----

=== Switch to build mode

When we have finished to test/push the project on the cloud machine, then we can start the process to build a docker image. In
Halkyon parlance, we need to change the deployment mode of the component to the `build` mode. Changing the deployment mode will
let Halkyon know that it needs to trigger an image build instead of relying on the supervisor-based approach provided by the
default `dev` mode. This, in turns, calls into Tekton to accomplish the required steps.

Once again, `hal` makes this process painless as this can be accomplished using the `hal component switch` command:
----
hal component switch -m build -c fruit-client-sb
INFO[0000] Component fruit-client-sb switched to build
hal component switch -m build -c fruit-backend-sb
INFO[0000] Component fruit-backend-sb switched to build
----

TODO: Add text here to tell to the students what is happening, what they could do

Test the service again
----
open "http://$(oc get routes/fruit-backend-sb --template={{.spec.host}})"
FRONTEND_URL=$(oc get routes/fruit-client-sb --template={{.spec.host}})
curl "http://${FRONTEND_URL}/api/client"
----

The Halkyon Team ;-)

**link:README.adoc[Home]**
